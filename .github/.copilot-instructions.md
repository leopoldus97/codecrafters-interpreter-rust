# Lox Interpreter in Rust - Custom Instructions

## Project Overview
This is a **Rust implementation of the Lox programming language interpreter** built as part of the CodeCrafters "Build Your Own Interpreter" challenge. The project implements a tree-walk interpreter for the Lox language, which supports:
- Variables and scoping
- Functions and closures
- Classes with inheritance
- Control flow (if/while)
- Object-oriented programming features

## Project Structure

### Core Architecture
The interpreter follows a classic multi-phase architecture:

1. **Scanner** (`scanner/`) - Lexical analysis
   - Tokenizes source code into tokens
   - Handles keywords, operators, literals, identifiers
   - Reports lexical errors with line numbers

2. **Parser** (`parser/`) - Syntax analysis
   - Builds Abstract Syntax Tree (AST) from tokens
   - Implements recursive descent parser
   - Returns structured statements and expressions

3. **Resolver** (`resolver/`) - Semantic analysis
   - Variable resolution and scope analysis
   - Tracks variable declarations and usage
   - Resolves local variables to their scope depth
   - Validates function returns and class features

4. **Interpreter** (`interpreter/`) - Execution
   - Tree-walk interpreter that executes AST
   - Manages runtime environment and variable bindings
   - Implements the Visitor pattern for AST traversal
   - Handles callable objects (functions, classes)

### File Organization
```
interpreter/src/
├── main.rs              # Entry point (REPL and file execution)
├── lib.rs               # Library root with global error flags
├── ast/                 # Abstract Syntax Tree definitions
│   ├── expr/            # Expression nodes (13 types)
│   │   ├── assign.rs, binary.rs, call.rs, get.rs
│   │   ├── grouping.rs, literal.rs, logical.rs
│   │   ├── set.rs, super_keyword.rs, this.rs
│   │   ├── unary.rs, variable.rs
│   │   └── mod.rs       # Expr trait definition
│   └── stmt/            # Statement nodes (10 types)
│       ├── block.rs, class.rs, expression.rs
│       ├── function.rs, if.rs, print.rs
│       ├── return.rs, var.rs, while.rs
│       └── mod.rs       # Stmt trait definition
├── scanner/             # Lexical analysis
│   ├── mod.rs          # Scanner implementation
│   ├── token.rs        # Token struct and Object enum
│   ├── token_type.rs   # TokenType enum
│   └── error.rs        # Scanner error reporting
├── parser/              # Syntax analysis
│   ├── mod.rs          # Parser implementation
│   └── error.rs        # Parser error reporting
├── resolver/            # Semantic analysis
│   └── mod.rs          # Resolver implementation
├── interpreter/         # Runtime execution
│   ├── mod.rs          # Interpreter and visitor implementation
│   ├── callable.rs     # Callable trait and implementations
│   ├── environment.rs  # Variable environment/scope management
│   └── error.rs        # Runtime error reporting
└── utils/               # Shared utilities
    ├── error.rs        # Error types (Error, Return, RuntimeError, ParseError)
    ├── report.rs       # Error reporting utilities
    └── mod.rs
```

## Key Implementation Details

### AST Design (Visitor Pattern)
- **Expr trait**: All expression types implement `Expr` with an `accept()` method
- **Stmt trait**: All statement types implement `Stmt` with an `accept()` method
- Expression types: Literal, Variable, Assign, Binary, Unary, Logical, Call, Get, Set, This, Super, Grouping
- Statement types: Expression, Print, Var, Block, If, While, Function, Return, Class

### Memory Management
- Uses `Rc<RefCell<>>` for shared mutable state (environments, callables)
- AST nodes stored as `Rc<dyn Trait>` for polymorphism
- HashMap with custom `ExprKey` wrapper for tracking variable resolutions

### Error Handling
- Global atomic flags: `HAD_ERROR`, `HAD_RUNTIME_ERROR`
- Custom error types: `Error`, `RuntimeError`, `ParseError`, `Return`
- Different exit codes for different error types (64, 65, 70, 74)
- Uses `anyhow` for error context, `thiserror` for custom error types

### Environment & Scoping
- Lexical scoping with linked environments (parent chain)
- Global environment for built-in functions (e.g., `clock()`)
- Local variables resolved at compile-time to depth levels
- Runtime lookup uses depth for O(1) variable access

### Callable Objects
- `Callable` trait implemented by functions and classes
- Built-in function: `clock()` returns current Unix timestamp
- User functions: `Fun::User` wraps function declarations
- Classes: Create instances and support methods/initializers

## Common Patterns & Conventions

### Code Style
- **Naming**: Snake_case for variables/functions, PascalCase for types
- **Modules**: Each AST node type has its own file
- **Error handling**: Use `Result<T, Error>` extensively
- **Imports**: Grouped by category (std, external crates, internal modules)

### Typical Workflows
1. **Adding new expression type**: Create file in `ast/expr/`, implement `Expr` trait, add visitor methods to Parser, Resolver, Interpreter
2. **Adding new statement type**: Create file in `ast/stmt/`, implement `Stmt` trait, add visitor methods to Parser, Resolver, Interpreter
3. **Debugging**: Check atomic error flags, review error reporting in each phase
4. **Testing**: Use CodeCrafters test suite via git push or local script execution

## Build & Run
- **Build**: `cargo build` (or use task `shell: build`)
- **Run**: `cargo run [script_file]` (or use task `shell: run`)
- **Watch mode**: Available tasks for auto-rebuilding
- **Dependencies**: anyhow, bytes, thiserror

## Current State
- ✅ Scanner: Complete (handles all tokens, literals, keywords)
- ✅ Parser: Complete (all expressions and statements)
- ✅ Resolver: Complete (variable resolution, function/class tracking)
- ✅ Interpreter: Complete (executes all language features)
- ✅ OOP Features: Classes, inheritance, methods, initializers
- ✅ Closures and functions
- ✅ Control flow and scoping

## Common Issues & Gotchas
1. **Rc/RefCell confusion**: Remember to `borrow()` or `borrow_mut()` before accessing
2. **Parser synchronization**: After errors, parser syncs to next statement boundary
3. **Variable resolution**: Resolver runs before interpreter to bind variables to depths
4. **Return handling**: Uses Rust's Result with custom `Return` error type for early returns
5. **Atomic flags**: Must use `Ordering::SeqCst` when reading/writing global error flags

## When Helping With This Project
- **Always check the phase**: Determine if the issue is in scanning, parsing, resolving, or interpreting
- **Follow Visitor pattern**: When adding features, implement accept/visit for all phases
- **Maintain error handling**: Preserve error reporting patterns and exit codes
- **Test incrementally**: Each change should pass existing tests before adding more
- **Respect the architecture**: Don't bypass phases or shortcut the compilation pipeline
- **Use Rc<dyn Trait>**: Keep polymorphic node types consistent with existing patterns
